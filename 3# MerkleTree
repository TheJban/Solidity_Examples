/*
для доказательства того, что наша транзакция попала в блок используют дерево Меркла(MerkleTree)
Данный контракт запрашивает 4 инпут данных, массив из двух хешей которые необходимо проверить
коренной хеш (root)и 
хеш дерева(leaf)

                 [0]
               /      \
           [0]         [1]*root
         /    \       /    \
      [0]*leaf[1]    [2]    [3]
      / \     /  \   /  \   / \
     [0][1]  [2][3] [4][5] [6][7]
            (proof)
для решения задачи необходимо знать 4 hash`a  - leaf, root, 2 хэша proof 

важно заметить:
1) что каждое левое значение является четным, либо 0,
а каждое правое нечетное.
2) индек верхнего уровня = нижнеуровневый левый индек/2 
то есть:

      [0]*leaf  [1]      [2]      [3]
      / \       /  \     /  \     / \
     [0][1]    [2][3]   [4][5]   [6][7]
    0 = 0/2   1 = 2/2   2 = 4/2  3 = 6/2


при решении задачи необходимо соблюдать порядок. все четные(+0) должны быть слева
значит при их хешировании мы должны выполнить условия распределения.

Если индекс, который мы ищем(current hash) = 3(нечетный), то его нужно добавить к proof hash
Если индекс, который мы ищем(current hash) = 2(четный), то к нему нужно добавить proof hash

      / \       /  \     /  \     / \
     [0][1]    [2][3]   [4][5]   [6][7]

дальше простыми словами, чтобы определить верхнеуровневый индекс, 
мы должны поделить текущий индекс на 2 и округлить в меньшую сторону

получается, что наш искомый индекс [3] , чтобы найти верхнеуровневый,
мы 3/2 = 1.5 и округляем в меньшую сторону = 1. 

подробное объяснение - https://www.youtube.com/watch?v=n6nEPaE7KZ8
*/


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.3;


contract Merkleproof {
 function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf,uint index) public pure returns(bool)
{
    

    bytes32 hash = leaf;
    
    for(uint i = 0;i<proof.length;i++){
        if(index % 2 == 0){
            hash = keccak256(abi.encodePacked(hash,proof[i]));
        }
        else{
            hash = keccak256(abi.encodePacked(proof[i],hash));
        }
        index = index/2;
    }

return hash ==root;


} 


}



/*
Если необходимо проверить в remix

   
    3rd leaf
    0xdca3326ad7e8121bf9cf9c12333e6b2271abe823ec9edfe42f813b1e768fa57b

    root
    0xcc086fcc038189b4641db2cc4f1de3bb132aefbd65d510d817591550937818c7

    index
    2

    proof
    ["0x8da9e1c820f9dbd1589fd6585872bc1063588625729e7ab0797cfc63a00bd950",
    "0x995788ffc103b987ad50f5e5707fd094419eb12d9552cc423bd0cd86a3861433"]
 


*/



